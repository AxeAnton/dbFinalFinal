package ru.ifmo.lessons.jpa.entity;
// 27. Ур.2 - как и для ORM, да и вообще для всего persistence, классы которые являются олицетворением таблицы в БД, называются КЛАССАМИ СУЩНОСТИ или ENTITY классами.
// 28. Ур.2 - т.к мы пишем в классе сущность, то бтблиотека на основенашего класса способна создать таблицу, для этого необходимо сделать две вещи:
// 29. Ур.2 - 1я идем в persistence.xml файл и создаем тэг класс. п. 30.
import jakarta.persistence.*;
import lombok.*;
import java.util.ArrayList;
import java.util.List;

// 4. Ур.2 - Важный момент, если необходимо, что бы аннотация применялась ко всему Классу ее размещаем НАД классом, прядок аннотаций и их место значения не имеет.

// 9. Ур.2 -проверка на null в сеттерах
@NonNull

//8. Ур.2 - можем поставить над классом, тогда модификатор доступа по умолчанию public, для всех полей
@Getter
@Setter


// 62. Ур.2 - @EqualsAndHashCode и @ToString добавляем (callSuper = TRUE!!!, что бы Id у автора отражался и Id учавствовал в генерации EqualsAndHashCode и Id будет отражаться в toString

// 7. Ур.2 - Варианты: @EqualsAndHashCode(callSuper = true) если необходимо, что бы поля родителя учавствовали в генерации Equals и HashCode
@EqualsAndHashCode(callSuper = true, exclude = {"name", "age"})

// 5. Ур.2 - ToString генерация метода должна быть импортирована
// 6. Ур.2 - Варианты генерации: @ToString(callSuper = true (необходима, что бы в метод toString были включены и родительские поля(по необходимости)), exclude = "fiedl" (исключения полей, которые не будут отражаться, если одно поле) exclude = {"fiedl1", "fiedl2"}(если несколько полей))
@ToString (callSuper = true)


// 31. Ур.2 -  шаг 2й, над классом сущности (public class Author extends BaseID {) прописывает анатацию Entity (экспортируется из import jakarta.persistence.*;), без анастации таблица не создастся. В доках можно посмотреть описание аннотации.
@Entity

// 32. Ур.2 - аннотация Table, не является обязательный, необходима для изменения имени таблицы, по умолчанию имя таблицы такое же как имя класса (только в нижнем регистре), позволяет добавить индексы и описать связи с другими таблицами.
@Table (name = "tb_authors")

/*
        //35. Ур.3. - для именованного запроса, на ЧИСТОМ SQL синтаксисе (использовать имена столбцов как в БД - author_name) прописываем аннотацию:
        @NamedNativeQueries({ // все именованные запросы будут располагаться в этом массиве {}
        // запросов может быть много, каждый отдельный запрос описывается отдельной аннотацией @NamedNativeQuery, каждому запросу добавляем имя (сами придумываем), затем запятая и сам запрос (использовать имена столбцов как в базе данных - author_name), затем добавляем resultClass = Author.class (это объекты какого класса мы хотим получить)
        @NamedNativeQuery(name = "getAllAuthors.native", query = "SELECT id, author_name, age FROM tb_authors", resultClass = Author.class) при необходимости далее - ,(запетая) @NamedNativeQueries (и следующий запрос)
        })
*/
//39. Ур.3. - для именованного простого SPQL запроса (НЕ ЧИСТSQ SQL синтаксис) (использовать названия как в программ - author и name(имена свойств)) прописываем аннотацию:
@NamedQueries({
        // 40. Ур.3. - запросы могут выглядеть так, т.к. в запросе будут фигурировать имена классов и имена свойств В ЭТИХ классах, и так сам запрос - SELECT (выбираем), FROM Author (откуда мы хотим получить данные по КЛАССУ автор) "a" - это будет ИМЯ ПЕРЕМЕННОЙ (необходим для получения конкретного запроса, например имя или что-то еще) в которой будет собираться экземпляр класс Author.
        @NamedQuery(name = "getAllAuthors.jpql", query = "SELECT a FROM author a"),
        // 41. Ур.3. - ВНИМАНИЕ, после первого запроса ставится ЗАПЯТАЯ, далее в текущем запросе после WHERE (где искать) берем переменную "a" - экземпляр класс Author, ставим точку и пишем название свойства (a.name) затем равно и после двоеточия какое то имя (:name), это все необходимо т.к после WHERE мы не можем прописать название столбцов.
        @NamedQuery(name = "getByNameAndAge.jpql", query = "SELECT a  /*  данная (а) вместо звездочки, означает, что мы получаем всю инфо для работы*/ FROM author a /*эта (a) имя объекта */ WHERE a.name = :name AND a.age = :age ")
        // 42. Ур.3. - далее переходим в Author
})

// 61. Ур.2 - теперь добавляем extends BaseID
public class Author extends BaseID {

    // 10. Ур.2 - при размещении Getter и Setter НАД свойствами (не над классом) означает, что они будут сгенерированы, только для этих свойств

    // 54. Ур.2 - т.к и у Article и у Author есть Id, а дублирование кода не приветствуется, то мы закомментируем все что про Id в Author, а дублирующийся код вынисим в родительский класс BaseID.
/*

    //  33. Ур.2 - указание на то что поле будет первичным ключем таблицы, можно оставить так тогда поле будет первичным ключем, но не будет авто инкремент (значение увеличиваться на ед.), если необходим такой функционал то добавляем п++
    @Id
    // 34. Ур.2 - авто инкремент (вместо AUTO может быть SEQUENCE), значение увеличивается на ед при каждой вставки, в скобках прописывается стратегия, они бываают разные. Механизм реализации такой, отдельно создается дополнительная табличка с первичными ключами
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;
*/


    // 36. Ур.2 - не обязательная аннотация для столбца, это описание столбца - например альтернативное name - имя, длинна имени столбца, unique - уникальный индекс (двух авторов быть не может), nullable может ли значение быть пустым (по умолчанию может), имя автора можно не вносить, далее insertable (какоето значение может не добавляться) или insertable (исключение из запроса добовления) и updatable (исключение из запроса перезаписи), length - про размер символьных ТД 255, ели больше то ТД будет изменен, если система управления поддерживает числа настраиваемые с плавающей точкой, то бубут использоваться эти значения - precision и scale (сколько всего символов и сколько после запятой например 4,52318)
    // 37. Ур.2 - @columDefinition = описание столбца на синтаксисе SQL. Можно полностью описать на синтексисе SQL, а можно частично, часть задать через свойства @Column, а часть на синтексе SQL
    @Column(name = "author_name", length = 100, nullable = false)
    private String name;

    private int age;

    // 35. Ур.2 - итак будет создана табличка с именем класса, но если есть @Table то с другим именем, в табличке будут столбцы id, name и age.

    //fetch FetchType.LAZY (.getArticle())- извлечение связанных данных, например извлечение автора по имени (название статей и т.д) FetchType.LAZY - все статии подтянутся по запросу......
    //fetch FetchType.EAREG - .............
    //  orphanRemaval - при удалении из коллекции соотведствующая статья будет удалена и из таблички так же.

    // CascadeType.ALL - все действия, добавления......
    // CascadeType.PERSIST - только у одного ..............
    // MERGE, REFRESH, - обновления
    //REMOVE, DETACH - удаление.

    // 12. Ур.3 - данная аннотация говорит о том что свойство применимо ко многим (один автор "One" ко многим "To" статьям "Many")
    // 13. Ур.3. - и если у нас аннотация ОДИН ко МНОГИМ то мы должны поставить круглые скобки и прописать mappedBy = и указать имя столбца в другом классе с которым сязан данный столбец, ВАЖНО имя столбца НЕ Id, а ИМЯ СВОЙСТВА которое мы указали в Article ( private Author author;). Фактически имя таблички только меленькими буквами.
/*
    // 14. Ур.3. - У данной аннотации @OneToMany есть три свойства:
    - mappedBy разобрали,
    - далее fetch - это необходима что бы лишние данные подтягивались или не подтягивались, есть два типа связанных данные, те которые мы будем получать, например по имени автора (если напишем запрос в классе Aplication и вызовем метод .getArticles() из author FromDB ), то подтянется автор, Id, имя и возраст, если выберем fetch = FetchType.LAZY, то статьи подтянутся ТОЛЬКО по запросу, если fetch = FetchType.EAGER то данные будут извлекаться сразу же и если автор написал милион статей то они будут выгружаться и тормозить программу, по этому надо быть аккуратным. подтянутся      orphanRemoval = true
    - orphanRemoval - это свойство в аннотации говорит о том что данные при удалены и из коллекции будут удалены и из таблицы (статью удалили из коллекции и из таблицы она удалилась так же).
    - cascade - в значение можно указать одно свойство или массив свойств через запятую, вообщем cascade необходим для каскадного обновления или удаления связанных данных (это связано с добавлением информации в табличку, например если в классе Application мы создадим новый объект статьи и автора, затем передаем автора ссылку на статью, а статье ссылку на автора, и если будет указанно каскадное добавление (cascade = CascadeType.PERSIST), то в записи (класс Application) между тегами manager.getTransaction().begin(); и manager.getTransaction().commit(); можно прописат .persist(paul);  только для автора, а вся остальная инфо загрузится автоматом. Пример п. 16-21. Если мы не указываем каскадное обнавление то между тегами то в метод persist необходимо вызвать и для автора и для статьи.
            Ниже варианты для  cascade = CascadeType.ХХХХХХ
            - All - все обновления,
            - а PERCIST - только добавление,
            - MARGE REFRESH - обновление,
            - REMOVE DETACH - удаление.
    У нас каскад начинается со стороны автора, то получается мы опишем объект автора, ему в список статей передадим статью и вызовем метод persist только на авторе, то инфо о статье добавится то же. Если я правильно понял, то каскад должен начинаться с того класса в котором он находится, то есть с Author.
 */
    @OneToMany (mappedBy = "author", cascade = CascadeType.PERSIST)
    //9. Ур.3 - необходимо добавить свойство article, т.к таблички автор и статья связаны между собой.
    private List<Article> articles;

    //10. Ур.3 - и необходимо добавить своцйство private List<Article> articles; в конструктор, что статьи будут храниться в = new ArrayList<>();
    // 44. Ур.2 -у класса сущности контрукторов может быть сколько угодно, но один должен быть пустой.
    public Author(){
        articles = new ArrayList<>();

    }
}
//11. Ур.3 - взаимосвязи между сущностями (табличками).
//@OneToMany:@ManyToOne - 1 : N // 12. Ур.3 - это наш вариант и теперь главное правильно заставить аннотации по классам автор и статьи.
//@ManyToMany : @ManyToMany - N : N
//@OneToOne : @OneToOne - 1 : 1